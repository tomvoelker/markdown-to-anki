<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to Anki HTML Converter</title>
    <meta name="description"
        content="Convert markdown with LaTeX math to Anki's HTML format. Supports single cards and batch processing.">

    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tomvoelker.github.io/markdown-to-anki/">
    <meta property="og:title" content="Markdown to Anki HTML Converter">
    <meta property="og:description"
        content="Simple tool to convert markdown with LaTeX to Anki HTML. Vibecoded for personal use.">
    <meta property="og:image" content="https://tomvoelker.github.io/markdown-to-anki/preview.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://tomvoelker.github.io/markdown-to-anki/">
    <meta property="twitter:title" content="Markdown to Anki HTML Converter">
    <meta property="twitter:description"
        content="Simple tool to convert markdown with LaTeX to Anki HTML. Vibecoded for personal use.">
    <meta property="twitter:image" content="https://tomvoelker.github.io/markdown-to-anki/preview.png">

    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üìù</text></svg>">
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
            },
            startup: {
                typeset: false
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
    <style>
        :root {
            --bg-primary: #f5f7fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f9fa;
            --text-primary: #1a1a1a;
            --text-secondary: #495057;
            --text-tertiary: #6c757d;
            --border-color: #e0e0e0;
            --border-subtle: #e8ecef;
            --accent-color: #0066cc;
            --accent-hover: #0052a3;
            --shadow: rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #242424;
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --text-tertiary: #888;
            --border-color: #404040;
            --border-subtle: #333;
            --accent-color: #4a9eff;
            --accent-hover: #6db0ff;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow);
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid var(--border-subtle);
            position: relative;
        }

        .dark-mode-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .dark-mode-toggle:hover {
            background: var(--bg-primary);
            transform: translateY(-1px);
        }

        h1 {
            color: var(--text-primary);
            margin-bottom: 12px;
            font-size: 2.2em;
            font-weight: 700;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.05em;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto 20px;
        }

        .description {
            background: var(--bg-tertiary);
            padding: 0;
            border-radius: 8px;
            margin-top: 20px;
            text-align: left;
            max-width: 900px;
            margin: 20px auto 0;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .description-header {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .description-header:hover {
            background: var(--bg-primary);
        }

        .description-header h3 {
            color: var(--text-primary);
            font-size: 1.1em;
            margin: 0;
        }

        .description-toggle {
            color: var(--accent-color);
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .description-toggle.open {
            transform: rotate(180deg);
        }

        .description-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 20px;
        }

        .description-content.open {
            max-height: 1000px;
            padding: 0 20px 20px;
        }

        .description ul {
            list-style: none;
            padding: 0;
        }

        .description li {
            padding: 6px 0;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .description li::before {
            content: "‚úì ";
            color: #28a745;
            font-weight: bold;
            margin-right: 8px;
        }

        .input-wrapper {
            position: relative;
        }

        .paste-sample-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.2);
        }

        .paste-sample-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 102, 204, 0.3);
        }

        .paste-sample-btn.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-button {
            padding: 12px 30px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .tab-button:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-color);
        }

        .tab-button.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .converter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .panel-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1.1em;
        }

        .status {
            font-size: 0.85em;
            padding: 4px 12px;
            border-radius: 12px;
            background: #e7f3ff;
            color: #0066cc;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .status.show {
            opacity: 1;
        }

        .status.copied {
            background: #d4edda;
            color: #28a745;
        }

        textarea {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s, background-color 0.3s, color 0.3s;
            line-height: 1.6;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        textarea::placeholder {
            color: var(--text-tertiary);
            opacity: 0.7;
        }

        #input {
            background: var(--bg-tertiary);
        }

        #output {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .preview-box {
            width: 100%;
            min-height: 400px;
            padding: 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            overflow-y: auto;
            line-height: 1.6;
            font-size: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        .preview-box:empty::before {
            content: 'Live preview will appear here...';
            color: var(--text-tertiary);
            font-style: italic;
        }

        .preview-box b {
            font-weight: 600;
        }

        .preview-box ul,
        .preview-box ol {
            margin: 10px 0;
            padding-left: 25px;
        }

        .preview-box li {
            margin: 8px 0;
        }

        .info-box {
            background: var(--bg-tertiary);
            border-left: 4px solid var(--accent-color);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .info-box strong {
            color: var(--accent-color);
        }

        .clear-btn {
            display: block;
            margin: 20px auto 0;
            padding: 12px 30px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .clear-btn:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .clear-btn:active {
            transform: translateY(0);
        }

        @media (max-width: 1200px) {

            .converter-grid,
            .batch-output {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 25px;
            }

            h1 {
                font-size: 1.5em;
            }

            textarea,
            .preview-box,
            .batch-input {
                min-height: 300px;
            }

            .tabs {
                flex-direction: column;
            }

            .tab-button {
                width: 100%;
            }
        }

        .copy-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2e7d32;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            opacity: 0;
            transform: translateY(-20px) scale(0.8);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 1000;
        }

        .copy-indicator.show {
            opacity: 1;
            transform: translateY(0) scale(1);
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            0% {
                transform: translateY(-20px) scale(0.8);
            }

            50% {
                transform: translateY(5px) scale(1.05);
            }

            100% {
                transform: translateY(0) scale(1);
            }
        }

        /* Batch Mode Styles */
        .batch-input-section {
            margin-bottom: 20px;
        }

        .batch-input {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            resize: vertical;
            line-height: 1.6;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: border-color 0.3s, background-color 0.3s, color 0.3s;
        }

        .batch-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .batch-output {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .card-item {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            position: relative;
            transition: all 0.3s;
        }

        .card-item:hover {
            border-color: var(--accent-color);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.15);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        .card-number {
            font-weight: 600;
            color: var(--accent-color);
            font-size: 0.9em;
        }

        .copy-card-btn {
            padding: 6px 16px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .copy-card-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .copy-card-btn:active::before {
            width: 300px;
            height: 300px;
        }

        .copy-card-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
        }

        .copy-card-btn:active {
            transform: translateY(0);
        }

        .copy-card-btn.copied {
            background: #2e7d32;
            animation: successPulse 0.5s ease;
        }

        .copy-card-btn.error {
            background: #d32f2f;
            animation: shake 0.5s ease;
        }

        @keyframes successPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .card-section {
            margin-bottom: 15px;
        }

        .card-section-title {
            font-weight: 600;
            color: var(--text-tertiary);
            font-size: 0.8em;
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .card-content {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 0.95em;
            line-height: 1.6;
            color: var(--text-primary);
        }

        .card-preview {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.95em;
            line-height: 1.6;
            color: var(--text-primary);
        }

        .card-preview b {
            font-weight: 600;
        }

        .card-preview ul,
        .card-preview ol {
            margin: 10px 0;
            padding-left: 25px;
        }

        .card-preview li {
            margin: 6px 0;
        }

        .batch-stats {
            text-align: center;
            padding: 15px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
            color: var(--accent-color);
        }

        .error-card {
            border-color: #ff6b6b;
            background: #fff5f5;
        }

        .error-message {
            color: #d32f2f;
            font-size: 0.9em;
            padding: 10px;
            background: #ffebee;
            border-radius: 6px;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="copy-indicator" id="copyIndicator">‚úì Copied to clipboard!</div>

    <div class="container">
        <div class="header">
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" id="darkModeToggle">üåô Dark</button>
            <h1>Markdown to Anki HTML Converter</h1>
            <p class="subtitle">
                A specialized tool for converting markdown with LaTeX math notation into Anki's HTML format.
                Supports bold text, italic, inline/block math equations, ordered/unordered lists, and more.
            </p>
            <div class="description">
                <div class="description-header" onclick="toggleDescription()">
                    <h3>What this tool does</h3>
                    <span class="description-toggle" id="descToggle">‚ñº</span>
                </div>
                <div class="description-content" id="descContent">
                    <ul>
                        <li><strong>Bold/Italic:</strong> Converts **bold** or __bold__ to &lt;b&gt;, and *italic* or
                            _italic_ to &lt;i&gt;</li>
                        <li><strong>Math:</strong> Inline math \(x\) or $x$ ‚Üí &lt;anki-mathjax&gt;, Block math \[x\] or
                            $$x$$ ‚Üí &lt;anki-mathjax block="true"&gt;</li>
                        <li><strong>Lists:</strong> Markdown lists (-, *, 1.) converted to proper HTML
                            &lt;ul&gt;/&lt;ol&gt;</li>
                        <li><strong>LaTeX environments:</strong> Supports \begin{align*}, \begin{equation}, etc.</li>
                        <li><strong>Auto-copy:</strong> Results are automatically copied to your clipboard</li>
                    </ul>
                </div>
            </div>

        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('single')">Single Card</button>
            <button class="tab-button" onclick="switchTab('batch')">Batch Mode</button>
        </div>

        <!-- Single Card Mode -->
        <div id="single-tab" class="tab-content active">
            <div class="converter-grid">
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">üì• Markdown Input</span>
                        <span class="status" id="inputStatus">Ready</span>
                    </div>
                    <div class="input-wrapper">
                        <button class="paste-sample-btn" id="singleSampleBtn" onclick="pasteSampleSingle()">Paste
                            Sample</button>
                        <textarea id="input"
                            placeholder="Paste your markdown here...&#10;&#10;Example:&#10;What is a **differential equation**?&#10;&#10;A function \(f(x)\) that satisfies...&#10;&#10;- **Item one**&#10;- **Item two**"></textarea>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">üì§ Anki HTML Output</span>
                        <span class="status" id="outputStatus">-</span>
                    </div>
                    <textarea id="output" readonly placeholder="Anki HTML will appear here..."></textarea>
                </div>

                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">üëÄ Live Preview</span>
                    </div>
                    <div id="preview" class="preview-box"></div>
                </div>
            </div>

            <button class="clear-btn" onclick="clearAll()">Clear All</button>

            <div class="info-box" style="margin-top: 20px;">
                <strong>Tip:</strong> The converted HTML is automatically copied to your clipboard.
                You can paste it directly into Anki's card editor.
            </div>
        </div>

        <!-- Batch Mode -->
        <div id="batch-tab" class="tab-content">
            <div class="batch-input-section">
                <div class="panel-header">
                    <span class="panel-title">üìã Batch Input</span>
                </div>
                <div class="input-wrapper">
                    <button class="paste-sample-btn" id="batchSampleBtn" onclick="pasteSampleBatch()">Paste
                        Sample</button>
                    <textarea id="batchInput" class="batch-input"
                        placeholder="Paste your batch of Q&A pairs here...&#10;&#10;Format:&#10;```&#10;Question&#10;```&#10;&#10;```&#10;Answer&#10;```&#10;&#10;-----&#10;&#10;Separate cards with ----- (5 dashes)"></textarea>
                </div>
            </div>

            <div id="batchStats" class="batch-stats" style="display: none;"></div>
            <div id="batchOutput" class="batch-output"></div>
        </div>

        <footer
            style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e8ecef; color: #6c757d; font-size: 0.9em;">
            <p style="margin-bottom: 12px;">
                Born from frustration with LLMs generating markdown that Anki can't handle.
                A simple, vibecoded tool built primarily for personal use.
            </p>
            <p style="margin-bottom: 15px; font-size: 0.9em;">
                <kbd style="padding: 2px 6px; background: #f0f0f0; border-radius: 3px; font-size: 0.85em;">Ctrl/Cmd +
                    K</kbd> Clear ¬∑
                <kbd style="padding: 2px 6px; background: #f0f0f0; border-radius: 3px; font-size: 0.85em;">Esc</kbd>
                Close info
            </p>
            <p style="margin-bottom: 15px; font-size: 0.9em;">
                <a href="https://github.com/tomvoelker/markdown-to-anki" target="_blank" rel="noopener"
                    style="color: #0066cc; text-decoration: none;">GitHub ‚Üó</a> ¬∑
                <a href="https://github.com/tomvoelker/markdown-to-anki/stargazers" target="_blank" rel="noopener"
                    style="color: #0066cc; text-decoration: none;">‚≠ê Star</a> ¬∑
                <a href="https://github.com/tomvoelker/markdown-to-anki/issues/new" target="_blank" rel="noopener"
                    style="color: #0066cc; text-decoration: none;">üêõ Report Bug</a>
            </p>
            <p style="font-size: 0.8em; color: #868e96;">
                Math rendering by <a href="https://www.mathjax.org/" target="_blank" rel="noopener"
                    style="color: #868e96;">MathJax</a> ¬∑
                All processing happens locally ¬∑
                Not affiliated with Anki
            </p>
        </footer>
    </div>

    <script>
        const input = document.getElementById('input');
        const output = document.getElementById('output');
        const preview = document.getElementById('preview');
        const inputStatus = document.getElementById('inputStatus');
        const outputStatus = document.getElementById('outputStatus');
        const copyIndicator = document.getElementById('copyIndicator');

        let debounceTimer;
        let mathJaxReady = false;

        // Wait for MathJax to be ready
        window.addEventListener('load', () => {
            const checkMathJax = setInterval(() => {
                if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                    window.MathJax.startup.promise.then(() => {
                        mathJaxReady = true;
                        clearInterval(checkMathJax);
                    });
                }
            }, 100);

            // Stop checking after 5 seconds
            setTimeout(() => clearInterval(checkMathJax), 5000);
        });

        function convertMarkdownToAnki(markdown) {
            if (!markdown.trim()) return '';

            let html = markdown;

            // STEP 0: Clean up citations
            html = html.replace(/\[cite_start\]/g, '');
            html = html.replace(/\[cite:\s*[^\]]*\]/g, '');

            // STEP 1: Protect math expressions first by converting them
            // Convert LaTeX environments (align, align*, equation, etc.)
            html = html.replace(/\\begin\{(align\*?|equation\*?|gather\*?|multline\*?)\}([\s\S]*?)\\end\{\1\}/g,
                '<anki-mathjax block="true">\\begin{$1}$2\\end{$1}</anki-mathjax>');

            // Convert block math - support both \[ ... \] and $$ ... $$
            html = html.replace(/\\\[([\s\S]*?)\\\]/g, '<anki-mathjax block="true">$1</anki-mathjax>');
            html = html.replace(/\$\$([\s\S]*?)\$\$/g, '<anki-mathjax block="true">$1</anki-mathjax>');

            // Convert inline math - support both \( ... \) and $ ... $
            html = html.replace(/\\\((.*?)\\\)/g, '<anki-mathjax>$1</anki-mathjax>');
            html = html.replace(/\$([^\$\n]+?)\$/g, '<anki-mathjax>$1</anki-mathjax>');

            // STEP 1.5: Handle bold/italic that contains math tags
            // Use non-greedy matching and ensure we don't match across multiple bold sections
            // Match **, then content (including <anki-mathjax> tags), then ** (but not ***)
            html = html.replace(/\*\*(?!\*)([\s\S]*?)\*\*(?!\*)/g, function (match, content) {
                if (content.includes('<anki-mathjax')) {
                    return '<b>' + content + '</b>';
                }
                return match;
            });
            html = html.replace(/__(?!_)([\s\S]*?)__(?!_)/g, function (match, content) {
                if (content.includes('<anki-mathjax')) {
                    return '<b>' + content + '</b>';
                }
                return match;
            });

            // STEP 2: Now convert bold/italic (but not inside <anki-mathjax> tags)
            // Split by math tags to avoid modifying content inside them
            let parts = html.split(/(<anki-mathjax[^>]*>[\s\S]*?<\/anki-mathjax>)/);

            const applyEmphasis = (segment) => {
                let part = segment;

                // Combined bold + italic
                part = part.replace(/\*\*\*([\s\S]+?)\*\*\*/g, '<b><i>$1</i></b>');
                part = part.replace(/___([\s\S]+?)___/g, '<b><i>$1</i></b>');
                part = part.replace(/\*\*_([\s\S]+?)_\*\*/g, '<b><i>$1</i></b>');
                part = part.replace(/__\*([\s\S]+?)\*__/g, '<b><i>$1</i></b>');

                // Bold
                part = part.replace(/\*\*(?!\*)([\s\S]+?)\*\*(?!\*)/g, '<b>$1</b>');
                part = part.replace(/__(?!_)([\s\S]+?)__(?!_)/g, '<b>$1</b>');

                // Italic (avoid consuming markdown list markers or bold markers)
                part = part.replace(/(^|[^*])\*([^*\n]+?)\*(?!\*)/g, (m, prefix, content) => prefix + '<i>' + content + '</i>');
                part = part.replace(/(^|[^_])_([^_\n]+?)_(?!_)/g, (m, prefix, content) => prefix + '<i>' + content + '</i>');

                return part;
            };

            for (let i = 0; i < parts.length; i++) {
                // Only process non-math parts
                if (!parts[i].startsWith('<anki-mathjax')) {
                    parts[i] = applyEmphasis(parts[i]);
                }
            }

            html = parts.join('');

            // Replace space after closing tags with &nbsp; (but not newlines!)
            html = html.replace(/<\/b>[ \t]+/g, '</b>&nbsp;');
            html = html.replace(/<\/i>[ \t]+/g, '</i>&nbsp;');

            // Handle lists
            const lines = html.split('\n');
            const processed = [];
            let inList = false;
            let listItems = [];
            let lastWasList = false;
            let isOrderedList = false;
            let emptyLineCount = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();

                // Track empty lines for paragraph breaks
                if (!trimmed) {
                    if (inList) {
                        // In a list, empty lines might end the list
                        const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
                        const nextIsList = nextLine && (nextLine.startsWith('- ') || nextLine.startsWith('* ') || nextLine.match(/^\d+\.\s/));
                        if (!nextIsList && inList) {
                            // End the list
                            const listTag = isOrderedList ? 'ol' : 'ul';
                            processed.push('<' + listTag + '>' + listItems.map(item => '<li>' + item + '</li>').join('') + '</' + listTag + '>');
                            inList = false;
                            listItems = [];
                            emptyLineCount = 0;
                        }
                        // Skip empty lines within lists
                        continue;
                    } else {
                        // Outside lists, track empty lines for paragraph breaks
                        emptyLineCount++;
                        continue;
                    }
                }

                const isNumberedItem = trimmed.match(/^\d+\.\s/);
                const isBulletItem = trimmed.startsWith('- ') || trimmed.startsWith('* ');

                if (isBulletItem || isNumberedItem) {
                    // List item (bullet or numbered)
                    if (!inList) {
                        inList = true;
                        listItems = [];
                        isOrderedList = !!isNumberedItem;
                        emptyLineCount = 0;
                    } else if ((!!isNumberedItem) !== isOrderedList) {
                        // List type changed, close previous list and start new one
                        const listTag = isOrderedList ? 'ol' : 'ul';
                        processed.push('<' + listTag + '>' + listItems.map(item => '<li>' + item + '</li>').join('') + '</' + listTag + '>');
                        listItems = [];
                        isOrderedList = !!isNumberedItem;
                    }

                    let content = trimmed.replace(/^[-*]\s|^\d+\.\s/, '');

                    // Check if next lines are indented (continuation of this item)
                    let j = i + 1;
                    while (j < lines.length && lines[j].startsWith('  ') && !lines[j].trim().match(/^[-*]\s|^\d+\.\s/)) {
                        const indentedLine = lines[j].trim();
                        // Check if it's a sub-item (a), b), etc.) or just continuation
                        if (indentedLine.match(/^[a-z]\)/)) {
                            content += ' <br>' + indentedLine;
                        } else {
                            content += ' ' + indentedLine;
                        }
                        i = j;
                        j++;
                    }

                    listItems.push(content);
                    lastWasList = true;
                } else {
                    // Not a list item
                    if (inList) {
                        // End the list
                        const listTag = isOrderedList ? 'ol' : 'ul';
                        processed.push('<' + listTag + '>' + listItems.map(item => '<li>' + item + '</li>').join('') + '</' + listTag + '>');
                        inList = false;
                        listItems = [];
                    }

                    // Add paragraph break if there were empty lines before this
                    if (emptyLineCount > 0 && processed.length > 0) {
                        for (let j = 0; j < emptyLineCount; j++) {
                            processed.push('<br>');
                        }
                    }

                    processed.push(trimmed);
                    emptyLineCount = 0;
                    lastWasList = false;
                }
            }

            // Close any remaining list
            if (inList) {
                const listTag = isOrderedList ? 'ol' : 'ul';
                processed.push('<' + listTag + '>' + listItems.map(item => '<li>' + item + '</li>').join('') + '</' + listTag + '>');
            }

            // Join processed parts with newlines to preserve spacing
            html = processed.join('\n');

            // Clean up multiple spaces (but not within <anki-mathjax> tags), preserve newlines
            let spaceParts = html.split(/(<anki-mathjax[^>]*>[\s\S]*?<\/anki-mathjax>)/);
            for (let i = 0; i < spaceParts.length; i++) {
                if (!spaceParts[i].startsWith('<anki-mathjax')) {
                    spaceParts[i] = spaceParts[i].replace(/[ \t]{2,}/g, ' ');
                }
            }
            html = spaceParts.join('');

            return html;
        }

        function renderPreview(ankiHtml) {
            if (!ankiHtml) {
                preview.innerHTML = '';
                return;
            }

            // Convert anki-mathjax tags to MathJax format for rendering
            let previewHtml = ankiHtml;

            // Block math
            previewHtml = previewHtml.replace(/<anki-mathjax block="true">([\s\S]*?)<\/anki-mathjax>/g, '\\[$1\\]');

            // Inline math
            previewHtml = previewHtml.replace(/<anki-mathjax>(.*?)<\/anki-mathjax>/g, '\\($1\\)');

            preview.innerHTML = previewHtml;

            // Typeset the math if MathJax is ready
            if (mathJaxReady && window.MathJax) {
                MathJax.typesetClear([preview]);
                MathJax.typesetPromise([preview]).catch((err) => console.log('MathJax error:', err));
            }
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                showCopyIndicator();
                trackEvent('/convert-single');
                return true;
            } catch (err) {
                console.error('Failed to copy:', err);
                showCopyError();
                return false;
            }
        }

        function showCopyError() {
            copyIndicator.textContent = '‚úó Copy failed!';
            copyIndicator.style.background = '#d32f2f';
            copyIndicator.classList.add('show');
            setTimeout(() => {
                copyIndicator.classList.remove('show');
                setTimeout(() => {
                    copyIndicator.textContent = '‚úì Copied to clipboard!';
                    copyIndicator.style.background = '#2e7d32';
                }, 300);
            }, 2000);
        }

        function showCopyIndicator() {
            copyIndicator.classList.add('show');
            setTimeout(() => {
                copyIndicator.classList.remove('show');
            }, 2000);
        }

        function updateStatus(element, text, copied = false) {
            element.textContent = text;
            element.classList.add('show');
            if (copied) {
                element.classList.add('copied');
            } else {
                element.classList.remove('copied');
            }
        }

        function hideStatus(element) {
            element.classList.remove('show');
        }

        input.addEventListener('input', () => {
            clearTimeout(debounceTimer);

            // Hide sample button on first input
            const sampleBtn = document.getElementById('singleSampleBtn');
            if (sampleBtn && !sampleBtn.classList.contains('hidden')) {
                sampleBtn.classList.add('hidden');
            }

            updateStatus(inputStatus, 'Converting...', false);

            debounceTimer = setTimeout(async () => {
                const markdown = input.value;
                const ankiHtml = convertMarkdownToAnki(markdown);
                output.value = ankiHtml;
                renderPreview(ankiHtml);

                if (ankiHtml) {
                    const copied = await copyToClipboard(ankiHtml);
                    if (copied) {
                        updateStatus(inputStatus, 'Ready', false);
                        updateStatus(outputStatus, 'Copied!', true);
                        setTimeout(() => {
                            hideStatus(outputStatus);
                        }, 2000);
                    }
                } else {
                    hideStatus(inputStatus);
                    hideStatus(outputStatus);
                }
            }, 300);
        });

        function clearAll() {
            input.value = '';
            output.value = '';
            preview.innerHTML = '';
            hideStatus(inputStatus);
            hideStatus(outputStatus);
            input.focus();
        }

        // Focus on input on load
        window.addEventListener('load', () => {
            input.focus();
        });

        // ============= DESCRIPTION & PASTE SAMPLE =============

        function toggleDescription() {
            const content = document.getElementById('descContent');
            const toggle = document.getElementById('descToggle');
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }

        const singleSample = `What are the **basic trigonometric identities**?

- \\(\\sin^2(x) + \\cos^2(x) = 1\\)
- \\(\\tan(x) = \\frac{\\sin(x)}{\\cos(x)}\\)
- \\(1 + \\tan^2(x) = \\sec^2(x)\\)`;

        const batchSample = `\`\`\`
What is the **Pythagorean theorem**?
\`\`\`

\`\`\`
The theorem states that \\(a^2 + b^2 = c^2\\) for any right triangle.
\`\`\`

-----

\`\`\`
Define **integration by parts**.
\`\`\`

\`\`\`
The formula is:
\\[ \\int u \\, dv = uv - \\int v \\, du \\]
\`\`\``;

        function pasteSampleSingle() {
            input.value = singleSample;
            input.dispatchEvent(new Event('input'));
            const btn = document.getElementById('singleSampleBtn');
            btn.classList.add('hidden');
            trackEvent('/sample-single');
        }

        function pasteSampleBatch() {
            batchInput.value = batchSample;
            batchInput.dispatchEvent(new Event('input'));
            const btn = document.getElementById('batchSampleBtn');
            btn.classList.add('hidden');
            trackEvent('/sample-batch');
        }

        // ============= BATCH MODE FUNCTIONS =============

        const batchInput = document.getElementById('batchInput');
        const batchOutput = document.getElementById('batchOutput');
        const batchStats = document.getElementById('batchStats');
        let batchDebounceTimer;

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        function parseBatchInput(text) {
            const cards = [];
            const sections = text.split(/\n\s*-----\s*\n/);

            sections.forEach((section, index) => {
                try {
                    // Extract code blocks (question and answer)
                    const codeBlockRegex = /```[ \t]*([a-zA-Z0-9_-]+)?[ \t]*\n?([\s\S]*?)```/g;
                    const matches = [...section.matchAll(codeBlockRegex)];

                    if (matches.length >= 2) {
                        const question = matches[0][2] ?? '';
                        const answer = matches[1][2] ?? '';

                        if (question || answer) {
                            cards.push({
                                index: cards.length + 1,
                                question: question,
                                answer: answer,
                                error: null
                            });
                        }
                    } else if (section.trim()) {
                        // Fallback: try to split by double newline if no code blocks
                        const parts = section.trim().split(/\n\s*\n/);
                        if (parts.length >= 2) {
                            cards.push({
                                index: cards.length + 1,
                                question: parts[0].trim(),
                                answer: parts.slice(1).join('\n\n').trim(),
                                error: null
                            });
                        }
                    }
                } catch (err) {
                    cards.push({
                        index: cards.length + 1,
                        question: '',
                        answer: '',
                        error: 'Failed to parse card: ' + err.message
                    });
                }
            });

            return cards;
        }

        function renderBatchCards(cards) {
            if (cards.length === 0) {
                batchOutput.innerHTML = '';
                batchStats.style.display = 'none';
                return;
            }

            batchStats.style.display = 'block';
            batchStats.textContent = `üìö ${cards.length} card${cards.length === 1 ? '' : 's'} processed`;

            trackEvent('/batch-process-' + cards.length + '-cards');

            batchOutput.innerHTML = cards.map(card => {
                if (card.error) {
                    return `
                        <div class="card-item error-card">
                            <div class="card-header">
                                <span class="card-number">Card ${card.index}</span>
                            </div>
                            <div class="error-message">${card.error}</div>
                        </div>
                    `;
                }

                const questionHtml = convertMarkdownToAnki(card.question);
                const answerHtml = convertMarkdownToAnki(card.answer);

                // Create preview HTML
                const questionPreview = questionHtml.replace(/<anki-mathjax block="true">([\s\S]*?)<\/anki-mathjax>/g, '\\[$1\\]')
                    .replace(/<anki-mathjax>(.*?)<\/anki-mathjax>/g, '\\($1\\)');
                const answerPreview = answerHtml.replace(/<anki-mathjax block="true">([\s\S]*?)<\/anki-mathjax>/g, '\\[$1\\]')
                    .replace(/<anki-mathjax>(.*?)<\/anki-mathjax>/g, '\\($1\\)');

                return `
                    <div class="card-item" id="card-${card.index}">
                        <div class="card-header">
                            <span class="card-number">Card ${card.index}</span>
                            <button class="copy-card-btn" onclick="copyCard(${card.index}, '${escapeHtml(questionHtml)}', '${escapeHtml(answerHtml)}')">
                                üìã Copy Both
                            </button>
                        </div>
                        
                        <div class="card-section">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span class="card-section-title">Question</span>
                                <button class="copy-card-btn" style="font-size: 0.75em; padding: 4px 10px;" 
                                        onclick="copyCardPart(${card.index}, 'question', '${escapeHtml(questionHtml)}')">
                                    Copy
                                </button>
                            </div>
                            <div class="card-preview card-preview-${card.index}-q">${questionPreview}</div>
                        </div>
                        
                        <div class="card-section">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span class="card-section-title">Answer</span>
                                <button class="copy-card-btn" style="font-size: 0.75em; padding: 4px 10px;" 
                                        onclick="copyCardPart(${card.index}, 'answer', '${escapeHtml(answerHtml)}')">
                                    Copy
                                </button>
                            </div>
                            <div class="card-preview card-preview-${card.index}-a">${answerPreview}</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Render MathJax for all previews
            if (mathJaxReady && window.MathJax) {
                const previews = batchOutput.querySelectorAll('.card-preview');
                MathJax.typesetClear([...previews]);
                MathJax.typesetPromise([...previews]).catch((err) => console.log('MathJax error:', err));
            }
        }

        function escapeHtml(text) {
            // IMPORTANT: Escape backslashes FIRST, before escaping quotes
            return text.replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/"/g, '&quot;')
                .replace(/\n/g, '\\n');
        }

        async function copyCard(index, questionHtml, answerHtml) {
            const text = `Question: ${questionHtml}\n\nAnswer: ${answerHtml}`;
            const btn = event.target;
            const originalText = btn.textContent;

            try {
                await navigator.clipboard.writeText(text);
                btn.textContent = '‚úì Copied!';
                btn.classList.remove('error');
                btn.classList.add('copied');
                showCopyIndicator();
                trackEvent('/batch-copy-both');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                btn.textContent = '‚úó Failed';
                btn.classList.remove('copied');
                btn.classList.add('error');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('error');
                }, 2000);
            }
        }

        async function copyCardPart(index, part, html) {
            const btn = event.target;
            const originalText = btn.textContent;

            try {
                await navigator.clipboard.writeText(html);
                btn.textContent = '‚úì';
                btn.classList.remove('error');
                btn.classList.add('copied');
                showCopyIndicator();
                trackEvent('/batch-copy-' + part);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 1500);
            } catch (err) {
                console.error('Failed to copy:', err);
                btn.textContent = '‚úó';
                btn.classList.remove('copied');
                btn.classList.add('error');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('error');
                }, 1500);
            }
        }

        batchInput.addEventListener('input', () => {
            clearTimeout(batchDebounceTimer);

            // Hide sample button on first input
            const sampleBtn = document.getElementById('batchSampleBtn');
            if (sampleBtn && !sampleBtn.classList.contains('hidden')) {
                sampleBtn.classList.add('hidden');
            }

            batchDebounceTimer = setTimeout(() => {
                const text = batchInput.value;
                if (text.trim()) {
                    const cards = parseBatchInput(text);
                    renderBatchCards(cards);
                } else {
                    batchOutput.innerHTML = '';
                    batchStats.style.display = 'none';
                }
            }, 500);
        });

        // ============= KEYBOARD SHORTCUTS =============

        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + K: Clear all
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                clearAll();
                batchInput.value = '';
                batchOutput.innerHTML = '';
                batchStats.style.display = 'none';
            }

            // Escape: Close description if open
            if (e.key === 'Escape') {
                const descContent = document.getElementById('descContent');
                const descToggle = document.getElementById('descToggle');
                if (descContent.classList.contains('open')) {
                    descContent.classList.remove('open');
                    descToggle.classList.remove('open');
                }
            }
        });

        // ============= DARK MODE =============

        function toggleDarkMode() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            const toggle = document.getElementById('darkModeToggle');

            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);

            toggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è Light' : 'üåô Dark';

            // Track theme change (only on deployed version)
            if (window.goatcounter) {
                window.goatcounter.count({ path: '/theme-' + newTheme, event: true });
            }
        }

        // Load theme: saved preference > system preference > light
        let theme = localStorage.getItem('theme');
        if (!theme) {
            // No saved preference, check system preference
            theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        if (theme === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
            // Update toggle button when it's available
            window.addEventListener('load', () => {
                const toggle = document.getElementById('darkModeToggle');
                if (toggle) toggle.textContent = '‚òÄÔ∏è Light';
            });
        }

        // ============= ANALYTICS (DEPLOYED VERSION ONLY) =============

        // Only load GoatCounter on GitHub Pages, not on localhost
        if (window.location.hostname.includes('github.io')) {
            const script = document.createElement('script');
            script.setAttribute('data-goatcounter', 'https://tomvoelker.goatcounter.com/count');
            script.setAttribute('async', '');
            script.src = '//gc.zgo.at/count.js';
            document.body.appendChild(script);
        }

        // Helper to track custom events (only works when deployed)
        function trackEvent(eventName) {
            if (window.goatcounter && window.location.hostname.includes('github.io')) {
                window.goatcounter.count({ path: eventName, event: true });
            }
        }
    </script>
</body>

</html>
